{"ast":null,"code":"'use client';\n\nimport { createContext, Component, createElement, isValidElement, useContext, useState, useMemo, forwardRef } from 'react';\nconst ErrorBoundaryContext = createContext(null);\nconst initialState = {\n  didCatch: false,\n  error: null\n};\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n    this.state = initialState;\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      didCatch: true,\n      error\n    };\n  }\n  resetErrorBoundary() {\n    const {\n      error\n    } = this.state;\n    if (error !== null) {\n      var _this$props$onReset, _this$props;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {\n        args,\n        reason: \"imperative-api\"\n      });\n      this.setState(initialState);\n    }\n  }\n  componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      didCatch\n    } = this.state;\n    const {\n      resetKeys\n    } = this.props;\n\n    // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onReset2, _this$props3;\n      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\"\n      });\n      this.setState(initialState);\n    }\n  }\n  render() {\n    const {\n      children,\n      fallbackRender,\n      FallbackComponent,\n      fallback\n    } = this.props;\n    const {\n      didCatch,\n      error\n    } = this.state;\n    let childToRender = children;\n    if (didCatch) {\n      const props = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n      if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else if (fallback === null || isValidElement(fallback)) {\n        childToRender = fallback;\n      } else {\n        throw error;\n      }\n    }\n    return createElement(ErrorBoundaryContext.Provider, {\n      value: {\n        didCatch,\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      }\n    }, childToRender);\n  }\n}\nfunction hasArrayChanged() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));\n}\nfunction assertErrorBoundaryContext(value) {\n  if (value == null || typeof value.didCatch !== \"boolean\" || typeof value.resetErrorBoundary !== \"function\") {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n}\nfunction useErrorBoundary() {\n  const context = useContext(ErrorBoundaryContext);\n  assertErrorBoundaryContext(context);\n  const [state, setState] = useState({\n    error: null,\n    hasError: false\n  });\n  const memoized = useMemo(() => ({\n    resetBoundary: () => {\n      context.resetErrorBoundary();\n      setState({\n        error: null,\n        hasError: false\n      });\n    },\n    showBoundary: error => setState({\n      error,\n      hasError: true\n    })\n  }), [context.resetErrorBoundary]);\n  if (state.hasError) {\n    throw state.error;\n  }\n  return memoized;\n}\nfunction withErrorBoundary(component, errorBoundaryProps) {\n  const Wrapped = forwardRef((props, ref) => createElement(ErrorBoundary, errorBoundaryProps, createElement(component, {\n    ...props,\n    ref\n  })));\n\n  // Format for display in DevTools\n  const name = component.displayName || component.name || \"Unknown\";\n  Wrapped.displayName = \"withErrorBoundary(\".concat(name, \")\");\n  return Wrapped;\n}\nexport { ErrorBoundary, ErrorBoundaryContext, useErrorBoundary, withErrorBoundary };","map":{"version":3,"names":["createContext","Component","createElement","isValidElement","useContext","useState","useMemo","forwardRef","ErrorBoundaryContext","initialState","didCatch","error","ErrorBoundary","constructor","props","resetErrorBoundary","bind","state","getDerivedStateFromError","_this$props$onReset","_this$props","_len","arguments","length","args","Array","_key","onReset","call","reason","setState","componentDidCatch","info","_this$props$onError","_this$props2","onError","componentDidUpdate","prevProps","prevState","resetKeys","hasArrayChanged","_this$props$onReset2","_this$props3","next","prev","render","children","fallbackRender","FallbackComponent","fallback","childToRender","Provider","value","a","undefined","b","some","item","index","Object","is","assertErrorBoundaryContext","Error","useErrorBoundary","context","hasError","memoized","resetBoundary","showBoundary","withErrorBoundary","component","errorBoundaryProps","Wrapped","ref","name","displayName","concat"],"sources":["E:/Dragon/IT/ciklum/X-course-task/x-course-task/node_modules/react-error-boundary/dist/react-error-boundary.esm.js"],"sourcesContent":["'use client';\nimport { createContext, Component, createElement, isValidElement, useContext, useState, useMemo, forwardRef } from 'react';\n\nconst ErrorBoundaryContext = createContext(null);\n\nconst initialState = {\n  didCatch: false,\n  error: null\n};\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n    this.state = initialState;\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      didCatch: true,\n      error\n    };\n  }\n  resetErrorBoundary() {\n    const {\n      error\n    } = this.state;\n    if (error !== null) {\n      var _this$props$onReset, _this$props;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {\n        args,\n        reason: \"imperative-api\"\n      });\n      this.setState(initialState);\n    }\n  }\n  componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      didCatch\n    } = this.state;\n    const {\n      resetKeys\n    } = this.props;\n\n    // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onReset2, _this$props3;\n      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\"\n      });\n      this.setState(initialState);\n    }\n  }\n  render() {\n    const {\n      children,\n      fallbackRender,\n      FallbackComponent,\n      fallback\n    } = this.props;\n    const {\n      didCatch,\n      error\n    } = this.state;\n    let childToRender = children;\n    if (didCatch) {\n      const props = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n      if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else if (fallback === null || isValidElement(fallback)) {\n        childToRender = fallback;\n      } else {\n        throw error;\n      }\n    }\n    return createElement(ErrorBoundaryContext.Provider, {\n      value: {\n        didCatch,\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      }\n    }, childToRender);\n  }\n}\nfunction hasArrayChanged() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));\n}\n\nfunction assertErrorBoundaryContext(value) {\n  if (value == null || typeof value.didCatch !== \"boolean\" || typeof value.resetErrorBoundary !== \"function\") {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n}\n\nfunction useErrorBoundary() {\n  const context = useContext(ErrorBoundaryContext);\n  assertErrorBoundaryContext(context);\n  const [state, setState] = useState({\n    error: null,\n    hasError: false\n  });\n  const memoized = useMemo(() => ({\n    resetBoundary: () => {\n      context.resetErrorBoundary();\n      setState({\n        error: null,\n        hasError: false\n      });\n    },\n    showBoundary: error => setState({\n      error,\n      hasError: true\n    })\n  }), [context.resetErrorBoundary]);\n  if (state.hasError) {\n    throw state.error;\n  }\n  return memoized;\n}\n\nfunction withErrorBoundary(component, errorBoundaryProps) {\n  const Wrapped = forwardRef((props, ref) => createElement(ErrorBoundary, errorBoundaryProps, createElement(component, {\n    ...props,\n    ref\n  })));\n\n  // Format for display in DevTools\n  const name = component.displayName || component.name || \"Unknown\";\n  Wrapped.displayName = \"withErrorBoundary(\".concat(name, \")\");\n  return Wrapped;\n}\n\nexport { ErrorBoundary, ErrorBoundaryContext, useErrorBoundary, withErrorBoundary };\n"],"mappings":"AAAA,YAAY;;AACZ,SAASA,aAAa,EAAEC,SAAS,EAAEC,aAAa,EAAEC,cAAc,EAAEC,UAAU,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,UAAU,QAAQ,OAAO;AAE1H,MAAMC,oBAAoB,GAAGR,aAAa,CAAC,IAAI,CAAC;AAEhD,MAAMS,YAAY,GAAG;EACnBC,QAAQ,EAAE,KAAK;EACfC,KAAK,EAAE;AACT,CAAC;AACD,MAAMC,aAAa,SAASX,SAAS,CAAC;EACpCY,WAAWA,CAACC,KAAK,EAAE;IACjB,KAAK,CAACA,KAAK,CAAC;IACZ,IAAI,CAACC,kBAAkB,GAAG,IAAI,CAACA,kBAAkB,CAACC,IAAI,CAAC,IAAI,CAAC;IAC5D,IAAI,CAACC,KAAK,GAAGR,YAAY;EAC3B;EACA,OAAOS,wBAAwBA,CAACP,KAAK,EAAE;IACrC,OAAO;MACLD,QAAQ,EAAE,IAAI;MACdC;IACF,CAAC;EACH;EACAI,kBAAkBA,CAAA,EAAG;IACnB,MAAM;MACJJ;IACF,CAAC,GAAG,IAAI,CAACM,KAAK;IACd,IAAIN,KAAK,KAAK,IAAI,EAAE;MAClB,IAAIQ,mBAAmB,EAAEC,WAAW;MACpC,KAAK,IAAIC,IAAI,GAAGC,SAAS,CAACC,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACJ,IAAI,CAAC,EAAEK,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGL,IAAI,EAAEK,IAAI,EAAE,EAAE;QACvFF,IAAI,CAACE,IAAI,CAAC,GAAGJ,SAAS,CAACI,IAAI,CAAC;MAC9B;MACA,CAACP,mBAAmB,GAAG,CAACC,WAAW,GAAG,IAAI,CAACN,KAAK,EAAEa,OAAO,MAAM,IAAI,IAAIR,mBAAmB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,mBAAmB,CAACS,IAAI,CAACR,WAAW,EAAE;QACrJI,IAAI;QACJK,MAAM,EAAE;MACV,CAAC,CAAC;MACF,IAAI,CAACC,QAAQ,CAACrB,YAAY,CAAC;IAC7B;EACF;EACAsB,iBAAiBA,CAACpB,KAAK,EAAEqB,IAAI,EAAE;IAC7B,IAAIC,mBAAmB,EAAEC,YAAY;IACrC,CAACD,mBAAmB,GAAG,CAACC,YAAY,GAAG,IAAI,CAACpB,KAAK,EAAEqB,OAAO,MAAM,IAAI,IAAIF,mBAAmB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,mBAAmB,CAACL,IAAI,CAACM,YAAY,EAAEvB,KAAK,EAAEqB,IAAI,CAAC;EACvK;EACAI,kBAAkBA,CAACC,SAAS,EAAEC,SAAS,EAAE;IACvC,MAAM;MACJ5B;IACF,CAAC,GAAG,IAAI,CAACO,KAAK;IACd,MAAM;MACJsB;IACF,CAAC,GAAG,IAAI,CAACzB,KAAK;;IAEd;IACA;IACA;IACA;;IAEA,IAAIJ,QAAQ,IAAI4B,SAAS,CAAC3B,KAAK,KAAK,IAAI,IAAI6B,eAAe,CAACH,SAAS,CAACE,SAAS,EAAEA,SAAS,CAAC,EAAE;MAC3F,IAAIE,oBAAoB,EAAEC,YAAY;MACtC,CAACD,oBAAoB,GAAG,CAACC,YAAY,GAAG,IAAI,CAAC5B,KAAK,EAAEa,OAAO,MAAM,IAAI,IAAIc,oBAAoB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,oBAAoB,CAACb,IAAI,CAACc,YAAY,EAAE;QAC1JC,IAAI,EAAEJ,SAAS;QACfK,IAAI,EAAEP,SAAS,CAACE,SAAS;QACzBV,MAAM,EAAE;MACV,CAAC,CAAC;MACF,IAAI,CAACC,QAAQ,CAACrB,YAAY,CAAC;IAC7B;EACF;EACAoC,MAAMA,CAAA,EAAG;IACP,MAAM;MACJC,QAAQ;MACRC,cAAc;MACdC,iBAAiB;MACjBC;IACF,CAAC,GAAG,IAAI,CAACnC,KAAK;IACd,MAAM;MACJJ,QAAQ;MACRC;IACF,CAAC,GAAG,IAAI,CAACM,KAAK;IACd,IAAIiC,aAAa,GAAGJ,QAAQ;IAC5B,IAAIpC,QAAQ,EAAE;MACZ,MAAMI,KAAK,GAAG;QACZH,KAAK;QACLI,kBAAkB,EAAE,IAAI,CAACA;MAC3B,CAAC;MACD,IAAI,OAAOgC,cAAc,KAAK,UAAU,EAAE;QACxCG,aAAa,GAAGH,cAAc,CAACjC,KAAK,CAAC;MACvC,CAAC,MAAM,IAAIkC,iBAAiB,EAAE;QAC5BE,aAAa,GAAGhD,aAAa,CAAC8C,iBAAiB,EAAElC,KAAK,CAAC;MACzD,CAAC,MAAM,IAAImC,QAAQ,KAAK,IAAI,IAAI9C,cAAc,CAAC8C,QAAQ,CAAC,EAAE;QACxDC,aAAa,GAAGD,QAAQ;MAC1B,CAAC,MAAM;QACL,MAAMtC,KAAK;MACb;IACF;IACA,OAAOT,aAAa,CAACM,oBAAoB,CAAC2C,QAAQ,EAAE;MAClDC,KAAK,EAAE;QACL1C,QAAQ;QACRC,KAAK;QACLI,kBAAkB,EAAE,IAAI,CAACA;MAC3B;IACF,CAAC,EAAEmC,aAAa,CAAC;EACnB;AACF;AACA,SAASV,eAAeA,CAAA,EAAG;EACzB,IAAIa,CAAC,GAAG/B,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKgC,SAAS,GAAGhC,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;EAC9E,IAAIiC,CAAC,GAAGjC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKgC,SAAS,GAAGhC,SAAS,CAAC,CAAC,CAAC,GAAG,EAAE;EAC9E,OAAO+B,CAAC,CAAC9B,MAAM,KAAKgC,CAAC,CAAChC,MAAM,IAAI8B,CAAC,CAACG,IAAI,CAAC,CAACC,IAAI,EAAEC,KAAK,KAAK,CAACC,MAAM,CAACC,EAAE,CAACH,IAAI,EAAEF,CAAC,CAACG,KAAK,CAAC,CAAC,CAAC;AACrF;AAEA,SAASG,0BAA0BA,CAACT,KAAK,EAAE;EACzC,IAAIA,KAAK,IAAI,IAAI,IAAI,OAAOA,KAAK,CAAC1C,QAAQ,KAAK,SAAS,IAAI,OAAO0C,KAAK,CAACrC,kBAAkB,KAAK,UAAU,EAAE;IAC1G,MAAM,IAAI+C,KAAK,CAAC,gCAAgC,CAAC;EACnD;AACF;AAEA,SAASC,gBAAgBA,CAAA,EAAG;EAC1B,MAAMC,OAAO,GAAG5D,UAAU,CAACI,oBAAoB,CAAC;EAChDqD,0BAA0B,CAACG,OAAO,CAAC;EACnC,MAAM,CAAC/C,KAAK,EAAEa,QAAQ,CAAC,GAAGzB,QAAQ,CAAC;IACjCM,KAAK,EAAE,IAAI;IACXsD,QAAQ,EAAE;EACZ,CAAC,CAAC;EACF,MAAMC,QAAQ,GAAG5D,OAAO,CAAC,OAAO;IAC9B6D,aAAa,EAAEA,CAAA,KAAM;MACnBH,OAAO,CAACjD,kBAAkB,CAAC,CAAC;MAC5Be,QAAQ,CAAC;QACPnB,KAAK,EAAE,IAAI;QACXsD,QAAQ,EAAE;MACZ,CAAC,CAAC;IACJ,CAAC;IACDG,YAAY,EAAEzD,KAAK,IAAImB,QAAQ,CAAC;MAC9BnB,KAAK;MACLsD,QAAQ,EAAE;IACZ,CAAC;EACH,CAAC,CAAC,EAAE,CAACD,OAAO,CAACjD,kBAAkB,CAAC,CAAC;EACjC,IAAIE,KAAK,CAACgD,QAAQ,EAAE;IAClB,MAAMhD,KAAK,CAACN,KAAK;EACnB;EACA,OAAOuD,QAAQ;AACjB;AAEA,SAASG,iBAAiBA,CAACC,SAAS,EAAEC,kBAAkB,EAAE;EACxD,MAAMC,OAAO,GAAGjE,UAAU,CAAC,CAACO,KAAK,EAAE2D,GAAG,KAAKvE,aAAa,CAACU,aAAa,EAAE2D,kBAAkB,EAAErE,aAAa,CAACoE,SAAS,EAAE;IACnH,GAAGxD,KAAK;IACR2D;EACF,CAAC,CAAC,CAAC,CAAC;;EAEJ;EACA,MAAMC,IAAI,GAAGJ,SAAS,CAACK,WAAW,IAAIL,SAAS,CAACI,IAAI,IAAI,SAAS;EACjEF,OAAO,CAACG,WAAW,GAAG,oBAAoB,CAACC,MAAM,CAACF,IAAI,EAAE,GAAG,CAAC;EAC5D,OAAOF,OAAO;AAChB;AAEA,SAAS5D,aAAa,EAAEJ,oBAAoB,EAAEuD,gBAAgB,EAAEM,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}